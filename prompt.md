# 项目描述
这是我的世界（Minecraft）lattice核心的多核并行计算架构设计 Prompt。尤其注重线程安全和稳定性，利用JNI技术实现多核并行加速，同时为Java端提供多核计算的能力。

## 核心目标
- 目标：在 CPU 多核上实现高效并行计算，将大部分重计算任务通过多线程并行化来提速；保持插件和业务逻辑的边界清晰，避免对核心数据结构的过度锁定与竞争。使用 C++20 标准，确保语法优雅和 AI 友好。
- 输出形式：架构设计文档、数据结构定义、接口契约、代码骨架、测试计划、性能基线与调优策略。

## 角色设定
- 你是 Lattice 核心的 CPU 并行化设计师与实现顾问，熟悉 C++20 的 std::thread、std::jthread、std::atomic、无锁队列、缓存友好的数据布局、以及高性能游戏/仿真架构的治理与可维护性。
- 输出应可直接移植到实际项目，包含清晰的设计意图、接口契约、可验证的最小实现和可执行的测试/性能计划。代码风格：驼峰命名、Doxygen 注释、异常安全、日志使用 spdlog。

## 任务分解与输出要求
1) 系统架构概览
- 给出分层架构图样（至少包含：CPU 调度层、事件/指令网关、CPU 线程池与工作队列、数据模型/内存池、外部输入/渲染/网络 I/O）。
- 说明各层职责、数据流向、跨层通信机制、容错逻辑与灾难恢复路径。
- 明确核心计算的分层分类（如 L0/L1/L2），以及插件边界治理策略，确保插件工作仅通过定义好的接口进入核心。

2) 数据模型与数据布局
- 提供主数据结构的设计（Chunk/Block/BlockState、Tile/Entity 的结构化布局、状态池、事件队列等）。
- 数据结构应具备：固定内存分配、句柄/索引引用、最小化指针跳转、缓存友好性、便于并行访问的分区策略。
- 给出内存池布局示例（静态分配区、工作区、双缓冲/环形缓冲区的划分），以及对齐要求与缓存行对齐策略。

3) CPU 多线程处理模型
- 设计一个高效的 CPU 线程池与任务调度模型（如工作窃取、无锁队列、批处理执行）。
- 任务打包与跨帧数据一致性的策略；避免频繁锁、减少同步点，确保帧/时间步的确定性。
- 提供一个简化的线程池骨架（可编译的 C++ 模板或伪代码），包含任务提交、工作分配、结果聚合的核心逻辑。

4) 插件治理与接口
- 给出统一的事件/指令接口契约（事件结构、命令缓冲格式、优先级、幂等性、错误回传）。
- 约束插件接入的边界：不直接访问主数据结构，通过事件网关与核心交互，提供简单的适配器层以对接 AI 产出。
- 插件分级策略（L0-L3），以及如何将插件输出转化为高效的并行任务包，确保对核心的影响可控。

5) 开发模板与代码骨架
- 提供可直接使用的代码骨架模板（C++ 为主，必要时给出伪代码）。包含：
  - 运行时入口与调度循环
  - 数据结构头文件与实现
  - 线程池及任务队列的实现骨架
  - 插件接口的示例实现（展示如何提交事件而非实现具体业务逻辑）
  - 日志、错误处理、断言与异常处理模式
- 风格应与现有项目一致，包含注释规范、错误处理、日志接口、并发安全要点。

6) 测试、验证与基线
- 制定并发性测试、数据一致性测试、死锁检测、性能基线测试。
- 给出基线指标：并发吞吐、每步的 CPU 利用率、任务队列的吞吐量、锁争用情况、单位时间的事件处理量。
- 提供可重复的测试场景和基准用例，便于回归与迭代。

7) 安全性、稳定性与容错
- 指出潜在风险点（锁竞争、活锁、内存分配碎片、线程间可见性问题、错误传播）。
- 给出治理原则（最小锁粒度、无锁数据结构、背压策略、兜底路径、快速回滚）。

8) 评审与交付要求
- 设计文档要点：设计意图、接口契约、边界条件、已知假设、潜在风险、回溯点。
- 产出物清单：架构文档、数据结构定义、API 文档、代码骨架、测试用例、CI/CD 集成计划、 ADR 草案。
- 代码审查要点：边界契约、可维护性、注释覆盖、测试覆盖、与现有代码风格的一致性。

9) 示范任务（仅示例，非实际任务）
- 示例 A：区块更新的 CPU 多线程骨架（包含输入输出数据格式、简化的更新逻辑、批处理接口）。
- 示例 B：CPU 端的事件包定义与无锁环形缓冲实现（锁/无锁版本、吞吐量目标）。
- 示例 C：插件接入示例（通过 API 提交一个简单的“放置方块/更新对象”事件，展示从插件到核心的完整路径）。

10) 交付与迭代计划
- 给出阶段性里程碑与成功标准：如第一阶段实现最小可行的线程池 + 基本数据模型 + 基本事件接口；第二阶段扩展 L0 计算、插件边界、基本测试。
- 指定评估周期、回滚策略、变更可追溯性要求（保留 prompts/模板版本、生成记录、责任人等）。

## 可选的输出格式与风格
- 设计文档 + 数据结构定义 + 代码骨架 + 测试计划的组合输出，亦可分阶段输出（先架构设计，再给数据结构定义，最后给代码骨架）。
- 如需单文件指令，请在同一个 Prompt 中要求：先给出系统架构文本描述，再给出数据结构定义（以 C++ 头文件风格书写），再给出简化的线程池/任务队列骨架，最后给出测试与评估计划。

## 文件树
'''text
lattice/                                 # Lattice 服务端核心 (fork 自 Paper)
├── pom.xml
├── build.gradle.kts
├── etc/                                        # Lattice 配置 & 构建脚本
│
├── src/main/java/                              # Java 源码
│   ├── io/lattice/                             # Lattice 自定义逻辑
│   │   ├── LatticeServer.java                  # 主入口
│   │   ├── performance/                        # 高性能调度优化逻辑
│   │   │   ├── NativeInterface.java            # 声明 native 方法（JNI桥）
│   │   │   └── AsyncTaskScheduler.java         # 调用 JNI 的任务调度器
│   │   └── world/                              # 世界/区块逻辑
│   │       └── LatticeChunkGen.java            # 示例: 使用 JNI 加速区块生成
│   └── org/bukkit/ ...                         # Bukkit API 兼容层
│
├── src/main/resources/
│   └── lattice.yml                             # 核心配置文件
│
├── native/                                     # C++ + JNI 代码
│   ├── CMakeLists.txt
│   ├── jni/                                    # 纯 JNI 桥接层
│   │   ├── native_interface.cpp                # 实现 NativeInterface.java 的方法
│   │   └── generated/                          # `javac -h` 生成的 JNI header
│   │       └── io_lattice_performance_NativeInterface.h
│   │
│   ├── core/                                   # 纯 C++ 高性能逻辑（与JNI解耦）
│   │   ├── CMakeLists.txt
│   │   ├── threadpool.hpp
│   │   ├── task_scheduler.cpp
│   │   ├── task_scheduler.hpp
│   │   └── worldgen/                           # 世界生成加速
│   │       ├── terrain_generator.cpp
│   │       └── terrain_generator.hpp
│   │
│   └── tests/                                  # 纯 C++ 单测（不依赖 Minecraft）
│       ├── test_threadpool.cpp
│       ├── test_worldgen.cpp
│       └── CMakeLists.txt
│
├── build/                                      # 编译输出
│   ├── lattice-server.jar                      # 服务端核心 jar
│   ├── liblattice_native.so / lattice_native.dll  # JNI 动态库
│   └── liblattice_core.a / lattice_core.lib    # 纯 C++ 静态库
│
├── docs/                                       # 文档
│   ├── architecture.md                         # 整体架构说明
│   ├── jni_call_flow.md                        # Java -> JNI -> C++ 调用流程
│   ├── threading_strategy.md                   # 多线程任务分配策略
│   └── upstream_sync.md                        # 如何与 Paper / Mojang 同步
│
└── CMakeLists.txt                              # 顶层构建入口
'''在 C++ 实现中加入错误检查（ZSTD_isError / libdeflate 返回码）与参数边界校验（必做）。
在 JNI 层实现 DirectByteBuffer API（零拷贝）并在 Java Handler 里改用 direct ByteBuf（显著减少拷贝）。
改用 thread_local 或上下文池管理 ZSTD_CCtx/Dctx（解决线程安全与复用）。
在 Java 静态初始化中实现 native 加载回退逻辑并在 pipeline 初始化时优雅回退到 Java 压缩。
在 CMake 中补足跨平台查找/构建逻辑并提供 Windows（MinGW/ MSYS2/ MSVC）的构建指导与条件分支。